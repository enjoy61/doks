---
title: "自定义生成器限制条件"
date: 2023-11-09T14:19:42
lastmod: 2023-11-09T14:20:53+08:00
draft: false
weight: 2016
---

## 说明 {#说明}

AI / EQS / Custom Test <br/>


## 验证EQS寻找补给时会把不可用补给考虑在内 {#验证eqs寻找补给时会把不可用补给考虑在内}


### 补给不可用逻辑 {#补给不可用逻辑}

补给被领取后, 设置在碰撞检测中忽略补给, 同时设置补给不可见, 使用定时器恢复碰撞和不可见选项 <br/>


### 存在的问题 {#存在的问题}

补给虽然无法参与碰撞, 在场景中也不可见, 但仍作为Actor存在于场景中, 于是NPC可以正常捕获 <br/>


### 验证 {#验证}

1.  初始状态 <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/all-visible.png" width="1000" /> <br/> <br/>
2.  设置场景中一个补给不可见 <br/>
    -   选中BP_STUAmmoPickup1 <br/>
    -   设置CollisionComponent不可见 <br/>
        `Details > Rendering > Visible` 取消勾选: 注意到, 碰撞胶囊已不可见 <br/>
        
        <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/collision-invisible.png" width="800" /> <br/> <br/>
    -   设置StaticMesh不可见 <br/>
        `Details > Rendering > Visible` 取消勾选 <br/>
        
        <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/mesh-invisible.png" width="800" /> <br/> <br/>
3.  移动EQS_TestPawn, 仍可以捕获不可见补给 <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/still-cap.png" width="1000" /> <br/> <br/>
4.  恢复补给状态 <br/>


## 考虑解决方案 {#考虑解决方案}

-   [ ] 自定义生成器: 筛选可见Actor <br/>
-   [X] 自定义生成器限制条件: 筛选可见Actor <br/>


## 考虑如何实现自定义生成器限制条件 {#考虑如何实现自定义生成器限制条件}

-   [ ] 判断组件可见性 <br/>
    根组件的选择很灵活, 在一些方案里, 即使根组件不可见, Actor也许能被正常观察; 而根组件可见, Actor也不一定能被正常观察到 <br/>
-   [X] 为补给添加接口: 判断补给是否可用 <br/>
    相应地, 该限制条件只能用于补给 <br/>


## 创建C++类 {#创建c-plus-plus-类}

| -  |                                 |
|----|---------------------------------|
| 基类 | EnvQueryTest                    |
| 名称 | EnvQueryTest_PickupCouldBeTaken |
| 路径 | AI/EQS                          |
| 属性 | Public                          |


## 学习EnvQueryTest及其派生类 {#学习envquerytest及其派生类}


### 派生类命名规则 {#派生类命名规则}

引擎使用该模板识别限制条件在EQS蓝图编辑器的名称 <br/>

```text
EnvQueryTest_子类别
```

<img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/env-query-tests.png" width="300" /> <br/> <br/>


### 筛选Actor接口 {#筛选actor接口}

`EnvQueryTest` <br/>

每次EQS运行时, 调用该函数; 在该函数中, 对捕获Actor进行筛选 <br/>
`public` <br/>

```cpp
/** Function that does the actual work */
virtual void RunTest(FEnvQueryInstance& QueryInstance) const { checkNoEntry(); }
```


### 筛选Actor逻辑 {#筛选actor逻辑}

参考限制条件Trace `EnvQueryTest_Trace` <br/>


#### 构造函数 {#构造函数}

```cpp
UEnvQueryTest_Trace::UEnvQueryTest_Trace(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
    Cost = EEnvTestCost::High;
    ValidItemType = UEnvQueryItemType_VectorBase::StaticClass();
    SetWorkOnFloatValues(false);

    Context = UEnvQueryContext_Querier::StaticClass();
    TraceData.SetGeometryOnly();
}
```

1.  Cost <br/>
    说明限制条件逻辑的复杂度, 复杂度越高, 开销就越大 <br/>
    使用枚举类型EEnvTestCost对其进行赋值 <br/>
    复杂度参考用于待测试Actor的数学运算 <br/>
2.  ValidItemType <br/>
    说明测试对象的数据类别, 数组或者元素 <br/>
    
    | -                            |    |
    |------------------------------|----|
    | UEnvQueryItemType_VectorBase | 数组 |
    | UEnvQueryItemType_ActorBase  | 元素 |
3.  SetWorkOnFloatValues <br/>
    限制条件部分参数的模式由FilterType决定, SetWorkOnFloatValues使用枚举类型EEnvTestFilterType对FilterType进行设置 <br/>
    
    | -       |      |
    |---------|------|
    | Minimum | 数值 |
    | Maximum | 数值 |
    | Range   | 数值 |
    | Match   | 布尔类型 |
    
    参数为true时, FilterType值为Range; 参数为false, FilterType值为Match: 这两个相当于是两种默认类型 <br/>
    
    如果FilterType为Range, 通常可以在蓝图编辑器中根据需求设置数值的其他模式Minimum和Maximum <br/>
    ```cpp
    void UEnvQueryTest::SetWorkOnFloatValues(bool bWorkOnFloats)
    {
        bWorkOnFloatValues = bWorkOnFloats;
    
        // Make sure FilterType is set to a valid value.
        if (bWorkOnFloats)
        {
            if (FilterType == EEnvTestFilterType::Match)
            {
                FilterType = EEnvTestFilterType::Range;
            }
        }
        else
        {
            if (FilterType != EEnvTestFilterType::Match)
            {
                FilterType = EEnvTestFilterType::Match;
            }
    
            // Scoring MUST be Constant for boolean tests.
            ScoringEquation = EEnvTestScoreEquation::Constant;
        }
    
        UpdatePreviewData();
    }
    ```


#### UEnvQueryTest_Trace::RunTest {#uenvquerytest-trace-runtest}

1.  FEnvQueryInstance::ItemIterator <br/>
    EQS专用的迭代器类型 <br/>
2.  获取Actor位置 <br/>
    ```cpp
    const FVector ItemLocation = GetItemLocation(QueryInstance, It.GetIndex()) + FVector(0, 0, ItemZ);            
    ```
3.  通用模板: 遍历捕获目标 <br/>
    ```cpp
    for (FEnvQueryInstance::ItemIterator It(this, QueryInstance); It; ++It)
    {
        const auto ItemActor = GetItemActor(QueryInstance, It.GetIndex()); // 后续需对ItemActor作出修改时, 移除const限定符
    
        // ...
    }
    ```
4.  设置Actor通过筛选 <br/>
    
    | -           |                                                                                      |
    |-------------|--------------------------------------------------------------------------------------|
    | TestPurpose | 枚举类型TEnumAsByteEEnvTestPurpose, 取值 `Filter Only` , `Score Only` , `Filter and Score` |
    | FilterType  |                                                                                      |
    | Score       | 如果时布尔类型, 为true, 通过筛选; 为false, 未通过. 如果是数值, 为权重值              |
    | bExpected   | 为true, Score决定筛选情况; 为false, 对Score对应的结果取反                            |
    
    ```cpp
    It.SetScore(TestPurpose, FilterType, true, true);
    ```
5.  设置Actor未通过筛选 <br/>
    
    | -        |                                                         |
    |----------|---------------------------------------------------------|
    | InStatus | 使用枚举类型EEnvItemStatus对其赋值, 表示是否通过筛选: `Failed` 或 `Passed` |
    | Score    | 使用默认值                                              |
    
    ```cpp
    It.ForceItemState(EEnvItemStatus::Failed);
    ```


## 修改补给基类 {#修改补给基类}

-   提供测试机制: 返回设置值 <br/>
-   通过定时器状态判断: 若定时器开启, 认为补给无效 <br/>


### 添加属性: 开启测试 {#添加属性-开启测试}

`protected` <br/>
`ShootThemUp: Pickups/STUBasePickup.h` <br/>

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite)
bool EnableTest = true;
```


### 添加属性: 测试结果 {#添加属性-测试结果}

`protected`       <br/>
`ShootThemUp: Pickups/STUBasePickup.h`       <br/>

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = "EnableTest"))
bool CouldBeTakenTest = true;
```


### 添加属性: 存放定时器描述符 {#添加属性-存放定时器描述符}

`private` <br/>
`ShootThemUp: Pickups/STUBasePickup.h`       <br/>

```cpp
FTimerHandle RespawnTimerHandle;
```

屏蔽定时器描述符变量定义 <br/>
`ShootThemUp: Pickups/STUBasePickup.cpp` <br/>

```cpp
// PickupWasTaken
```


### 添加接口: 判断补给是否可用 {#添加接口-判断补给是否可用}

`public` <br/>
`ShootThemUp: Pickups/STUBasePickup.h` <br/>

```cpp
bool CouldBeTaken() const;
```

`ShootThemUp: Pickups/STUBasePickup.cpp` <br/>

```cpp
bool ASTUBasePickup::CouldBeTaken() const
{
    if (EnableTest)
    {
        return CouldBeTakenTest;
    }
    else
    {
        return !GetWorldTimerManager().IsTimerActive(RespawnTimerHandle);
    }
}
```


## 实现EnvQueryTest_PickupCouldBeTaken {#实现envquerytest-pickupcouldbetaken}


### 构造函数 {#构造函数}

| -      |
|--------|
| 低开销 |
| 单个元素 |
| 使用布尔类型 |

`public` <br/>
`ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.h` <br/>

```cpp
UEnvQueryTest_PickupCouldBeTaken(const FObjectInitializer &ObjectInitializer);
```

`ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.cpp`       <br/>

```cpp
#include "EnvironmentQuery/Items/EnvQueryItemType_ActorBase.h"

UEnvQueryTest_PickupCouldBeTaken::UEnvQueryTest_PickupCouldBeTaken(const FObjectInitializer &ObjectInitializer) //
: Super (ObjectInitializer)
{
    Cost = EEnvTestCost::Low;
    ValidItemType = UEnvQueryItemType_ActorBase::StaticClass();
    SetWorkOnFloatValues(false);
}
```


### RunTest {#runtest}

`public` <br/>
`ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.h` <br/>

```cpp
virtual void RunTest(FEnvQueryInstance& QueryInstance) const override;
```

`ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.cpp`       <br/>

```cpp
#include "Pickups/STUBasePickup.h"

void UEnvQueryTest_PickupCouldBeTaken::RunTest(FEnvQueryInstance& QueryInstance) const
{
    for (FEnvQueryInstance::ItemIterator It(this, QueryInstance); It; ++It)
    {
        const auto ItemActor = GetItemActor(QueryInstance, It.GetIndex());
        const auto PickupActor = Cast<ASTUBasePickup>(ItemActor);
        if (!PickupActor) continue;

        const auto CouldBeTaken = PickupActor->CouldBeTaken();
        if (CouldBeTaken)
        {
            It.SetScore(TestPurpose, FilterType, true, true);
        }
        else
        {
            It.ForceItemState(EEnvItemStatus::Failed);
        }
    }
}
```


## 使用PickupCouldBeTaken {#使用pickupcouldbetaken}

1.  为EQS_FindAmmoPickup的生成器添加PickupCouldBeTaken <br/>
    `Add Test > Pickup Could be Taken` <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/add-test.png" width="800" /> <br/> <br/>
2.  选中EQS_TestPawn, 合适补给被标记为绿色 <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/all-ok.png" width="1000" /> <br/> <br/>
3.  选择一个被标记为绿色的补给, 使之状态无效 <br/>
    勾选 `Enable Test` , 取消 `Could Be Taken Test` 勾选 <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/test-one-invalid.png" width="1000" /> <br/> <br/>
4.  移动EQS_TestPawn, 该补给不再有效 <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/expected.png" width="1000" /> <br/> <br/>


### 注意 {#注意}

1.  通过勾选和取消勾选生成器的限制条件, 可以对若干指定项进行测试, 且立即生效 <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/check-all.png" width="1000" /> <br/> <br/>
    
    <img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/uncheck.png" width="1000" /> <br/> <br/>
2.  当前, `PickupCouldBeTaken > Details > Filter > Bool Match` 是否勾选无区别. 而在限制条件的设计中, 期望其勾选状态的改变应该导致相反的结果 <br/>


## EnvQueryTest取反逻辑 {#envquerytest取反逻辑}

1.  获取BoolMatch值: 决定是否对筛选结果取反 <br/>
    `EnvQueryTest_Trace` <br/>
    BoolValue是一个特殊类型, 通过成员函数GetValue获取布尔值 <br/>
    ```cpp
    UObject* DataOwner = QueryInstance.Owner.Get();
    BoolValue.BindData(DataOwner, QueryInstance.QueryID);
    
    bool BoolMatchValue = BoolValue.GetValue();
    ```
2.  使用SetScore统一设置是否通过筛选 <br/>
    
    | Score | 筛选结果 |
    |-------|------|
    | true  | 通过筛选 |
    | false | 未通过筛选 |
    
    | `Bool Match` | 是否对结果取反 |
    |--------------|---------|
    | true         |         |
    | false        | 对结果取反 |
    
    ```cpp
    It.SetScore(TestPurpose, FilterType, Score, BoolMatchValue);
    ```


## 实现EnvQueryTest_PickupCouldBeTaken结果取反 {#实现envquerytest-pickupcouldbetaken结果取反}

| CouldBeTaken |       |
|--------------|-------|
| true         | 可以被拾取 |
| false        | 无法被拾取 |

| `Bool Match` | -     |
|--------------|-------|
| true         |       |
| false        | 对结果取反 |

```cpp
void UEnvQueryTest_PickupCouldBeTaken::RunTest(FEnvQueryInstance& QueryInstance) const
{
    const auto DataOwner = QueryInstance.Owner.Get();
    BoolValue.BindData(DataOwner, QueryInstance.QueryID);

    const auto BoolMatchValue = BoolValue.GetValue();
    for (FEnvQueryInstance::ItemIterator It(this, QueryInstance); It; ++It)
    {
        const auto ItemActor = GetItemActor(QueryInstance, It.GetIndex());
        const auto PickupActor = Cast<ASTUBasePickup>(ItemActor);
        if (!PickupActor) continue;

        const auto CouldBeTaken = PickupActor->CouldBeTaken();
        It.SetScore(TestPurpose, FilterType, CouldBeTaken, BoolMatchValue);
    }
}
```


## 查看取反效果 {#查看取反效果}

`EQS_FindAmmoPickup > PickupCouldBeTaken > Details > Filter > Bool Match` <br/>

默认勾选 <br/>

<img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/bool-match-check.png" width="1000" /> <br/> <br/>

取消勾选 <br/>

<img src="/pic/非玩家游戏角色行为/自定义生成器限制条件/bool-match-uncheck.png" width="1000" /> <br/> <br/>

**为EQS_FindHealthPickup生成器添加限制条件PickupCouldBeTaken** <br/>


## 设置补给默认关闭测试 {#设置补给默认关闭测试}

默认关闭测试. 之前默认开启. 不用挨个关闭补给测试 <br/>
`ShootThemUp: Pickups/STUBasePickup.h` <br/>

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite)
bool EnableTest = false;
```

