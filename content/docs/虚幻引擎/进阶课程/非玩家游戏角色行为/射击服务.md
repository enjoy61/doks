---
title: "射击服务"
date: 2023-10-31T19:23:24
lastmod: 2023-11-01T18:59:46+08:00
draft: false
weight: 2008
---

## 说明 {#说明}

自定义服务: 对距离最近敌人射击 <br/>


## 创建服务类 {#创建服务类}

| -    |                |
|------|----------------|
| base | BTService      |
|      | Public         |
|      | AI/Services    |
|      | STUFireService |


### 添加构造函数: 设置名称 {#添加构造函数-设置名称}

`public` <br/>
`ShootThemUp: AI/Services/STUFireService.h` <br/>

```cpp
USTUFireService();
```

`ShootThemUp: AI/Services/STUFireService.cpp` <br/>

```cpp
USTUFireService::USTUFireService()
{
    NodeName = "Fire";
}
```


### 添加属性: 存放敌人信息 {#添加属性-存放敌人信息}

`protected` <br/>
`ShootThemUp: AI/Services/STUFireService.h` <br/>

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite)
FBlackboardKeySelector EnemyActorKey;
```


### 服务逻辑: 实现TickNode {#服务逻辑-实现ticknode}

`protected` <br/>
`ShootThemUp: AI/Services/STUFireService.h` <br/>

```cpp
virtual void TickNode(UBehaviorTreeComponent &OwnerComp, uint8 *NodeMemory, float DeltaSeconds) override;
```

不需要检查EnemyActor的设置情况, 上节的Decorator提供检查; 还是推荐一个自给自足的逻辑闭环 <br/>
`ShootThemUp: AI/Services/STUFireService.cpp` <br/>

```cpp
#include "BehaviorTree/BlackboardComponent.h"
#include "AIController.h"
#include "Components/STUWeaponComponent.h"
#include "STUUtils.h"

void USTUFireService::TickNode(UBehaviorTreeComponent &OwnerComp, uint8 *NodeMemory, float DeltaSeconds)
{
    const auto Controller = OwnerComp.GetAIOwner();
    const auto Blackboard = OwnerComp.GetBlackboardComponent();

    const auto HasAim = Blackboard && Blackboard->GetValueAsObject(EnemyActorKey.SelectedKeyName);

    if (Controller)
    {
        const auto WeaponComponent = STUUtils::GetSTUPlayerComponent<USTUWeaponComponent>(Controller->GetPawn());
        if (WeaponComponent)
        {
            HasAim ? WeaponComponent->FireStart() : WeaponComponent->FireStop();
        }
    }
}
```


## 修改武器基类射击逻辑 {#修改武器基类射击逻辑}

`STUBaseWeapon` <br/>

NPC的控制器类型为AIController, 控制器相关逻辑需调整 <br/>

获取子弹轨迹信息: GetTraceData; 调用GetPlayerViewPoint; 被武器派生类的MakeShot调用 <br/>


### APlayerController::GetPlayerViewPoint {#aplayercontroller-getplayerviewpoint}

AIController不具有类似功能的成员函数 <br/>

若游戏角色的控制器类型为APlayerController, 走原有逻辑; 自行设置子弹起点和方向向量 <br/>

`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// GetPlayerViewPoint

const auto STUCharacter = Cast<ACharacter>(GetOwner());
if (!STUCharacter) return false;

if (STUCharacter->IsPlayerControlled())
{
    // 原逻辑
}
else
{
    ViewLocation = GetMuzzleWorldLocation();
    ViewRotation = WeaponMeshComponent->GetSocketRotation(MuzzleSocketName);
}
return true;
```


## 查看 {#查看}


### 调整NPC视觉感知参数 {#调整npc视觉感知参数}

`BP_STUAIController > STUAIPerceptionComponent` <br/>

|                                  | -    |
|----------------------------------|------|
| Sight Radius                     | 2000 |
| Lose Sight Radius                | 2500 |
| PeripheralVisionHalfAngleDegrees | 90   |

<img src="/pic/非玩家游戏角色行为/射击服务/aicontroller.png" width="1000" /> <br/> <br/>


### 设置行为树 {#设置行为树}

`BT_STUCharacter` <br/>

-   为Attack添加射击服务 <br/>
-   设置射击目标 <br/>
    选中 `STUFireService` , 设置 `Details > STUFire Service > Enemy Actor Key` 为EnemyActor <br/>
    
    <img src="/pic/非玩家游戏角色行为/射击服务/bt.png" width="1000" /> <br/> <br/>


### 总结 {#总结}

1.  NPC注意到敌人就可以瞄准射击, 这一点太猛了 <br/>
2.  之前为NPC添加了转向过渡动画, 而射击在这之前 <br/>

