---
title: "添加走路转向动画"
date: 2023-06-11T06:17:45
lastmod: 2023-08-06T18:43:47+08:00
draft: false
weight: 1010
---

## 概览 {#概览}


### 已实现动作 {#已实现动作}

-   Walk: 从静止到跑起来支持加速，使用 `BS_Locomotion_Walk_1D` <br/>
-   Run: `BS_Locomotion_Run` <br/>
-   Jump: `JumpStart` , `JumpEnd` , `JumpLoop` <br/>


### 本节内容 {#本节内容}

-   重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 <br/>
-   之后还有 装弹 `Reloading` , 死亡 `Death` 和瞄准 `Aiming` 动画 <br/>


### 2D混合空间 {#2d混合空间}

`Blend Space` <br/>
拥有两个轴， `Vertial Axis` 和 `Horizontal Axis` <br/>


## 建模 {#建模}


### 游戏角色朝向 {#游戏角色朝向}

| -     |                 |
|-------|-----------------|
| 前进和后退 | `ForwardVector` |
| 左右  | `RightVector`   |

-   游戏角色前后左右移动有使用到这两个方向向量 <br/>
-   我们水平移动鼠标时， `ForwardVector` 和 `RightVector` 随之发生改变 <br/>
-   在视觉上， `ForwardVector` 一直向前， `RightVector` 一直向右，二者在水平面垂直 <br/>


### 数学基础 {#数学基础}


#### 点乘 {#点乘}

<img src="/pic/角色和动画/添加转向动画/实现转向动画/点乘.png" width="600" /> <br/> <br/>

-   `计算向量夹角` <br/>
-   其中一个向量为 `0向量` 时，点乘结果为 `0` ，而反余弦计算得到其夹角为 `PI/2` <br/>


#### 叉乘 {#叉乘}

<img src="/pic/角色和动画/添加转向动画/实现转向动画/叉乘.png" width="600" /> <br/> <br/>

-   `将向量夹角从[0, PI]扩充到[-PI, PI]` <br/>
-   `theta` 为 `0` `PI` 和 `-PI` 时，叉乘结果为 `0` ，此时无法通过向量确定平面，也就无法得到平面法向量 <br/>
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/叉乘说明.png" width="300" /> <br/> <br/>
-   向量c的z坐标 `c.z` 的符号说明向量的方向 <br/>


### 速度方向 {#速度方向}

`VelocityVector` <br/>

-   `Actor` 的速度是一个矢量，其表现是单位时间内的位移方向 <br/>
-   当速度不为 `0` ， `VelocityVector` 和 `ForwardVector` 的夹角与此时 `Actor` 应该展现的动画有关 <br/>
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/夹角说明.png" width="600" /> <br/> <br/>


### 计算游戏角色前进方向和速度方向的夹角 {#计算游戏角色前进方向和速度方向的夹角}

`VelocityVector` 和 `ForwardVector` 的夹角通过向量点乘反余弦结果和向量叉乘结果z分量符号 `sign(c.z)` 的乘积得到 <br/>

| 夹角           | 反余弦结果   | sign(c.z) | 目的动画       | 使用乘积效果 |
|--------------|---------|-----------|------------|--------|
| 0              | 0            | 0         | Fwd            | o      |
| ( 0, PI/2 )    | ( 0, PI/2 )  | 1         | Fwd &gt; Right | o      |
| PI/2           | PI/2         | 1         | Right          | o      |
| ( PI/2, PI )   | ( PI/2, PI ) | 1         | Right &gt; Bwd | o      |
| PI             | PI           | 0         | Bwd            | x      |
| -PI            | PI           | 0         | Bwd            | x      |
| ( -PI, -PI/2 ) | ( PI/2, PI ) | -1        | Left &gt; Bwd  | o      |
| -PI/2          | PI/2         | -1        | Left           | o      |
| ( -PI/2, 0 )   | ( 0, PI/2 )  | -1        | Fwd &gt; Left  | o      |


### 分析特殊情形 {#分析特殊情形}

坐标 ( `Velocity` , `Angle` ) <br/>


#### 速度为0，夹角应该为0 {#速度为0-夹角应该为0}

`Velocity` 为 `0` ，( 0, 任意 ) 对应 `Idle` ，可以显示正确动画 <br/>


#### 速度不为0，夹角为0或PI时 {#速度不为0-夹角为0或pi时}

-   叉乘结果为 `0` ，即sign(c.z)为 `0` ，即计算夹角得到 `0` ，对应动画 `RunFwd` <br/>
-   夹角为 `0` 使用 `RunFwd` 正确，夹角为 `PI` 应该使用 `RunBwd` <br/>
-   夹角为 `PI` 时，不使用乘积，使用反余弦结果 <br/>


### 可以在蓝图中实现夹角的计算，也可以在C++中实现 {#可以在蓝图中实现夹角的计算-也可以在c-plus-plus-中实现}


## 绘制ForwardVector，RightVector和VelocityVector {#绘制forwardvector-rightvector和velocityvector}

`虚幻编辑器` <br/>

使用 `DrawDebugArrow` : `Duration` 为 `0` ，每帧都进行绘画 <br/>

| -  |            |
|----|------------|
| 起点 | Actor 当前位置 |
| 终点 | 起点 + 偏移 |


### 绘制 ForwardVector {#绘制-forwardvector}

|    | -         |
|----|-----------|
| 偏移 | 放大的前进方向向量 |

<img src="/pic/角色和动画/添加转向动画/实现转向动画/绘制ForwardVector.png" width="900" /> <br/> <br/>


### 绘制 RightVector {#绘制-rightvector}

|    | -         |
|----|-----------|
| 偏移 | 放大的向右方向向量 |

<img src="/pic/角色和动画/添加转向动画/实现转向动画/绘制RightVector.png" width="900" /> <br/> <br/>


### 绘制 VelocityVector {#绘制-velocityvector}

|    | -           |
|----|-------------|
| 偏移 | 放大的速度方向单位向量 |

<img src="/pic/角色和动画/添加转向动画/实现转向动画/绘制VelocityVector.png" width="900" /> <br/> <br/>


### 效果图 {#效果图}

一直显示 `ForwardVector` 和 `RightVector` ，有速度才会显示 `VelocityVector` <br/>

<img src="/pic/角色和动画/添加转向动画/实现转向动画/ForwardVector和RightVector效果图.png" width="700" /> <br/> <br/>


### 优化显示 {#优化显示}

`项目设置 > Engine > Rendering > Default Settings > Auto Exposure，取消勾选` <br/>

-   旨在模拟人眼适应不同亮度 <br/>
-   看不出区别, 取消设置 <br/>


## 添加走路转向动画 {#添加走路转向动画}

`虚幻编辑器`      <br/>


### 创建2D混合空间资产作为走路转向动画 {#创建2d混合空间资产作为走路转向动画}

`Blend Space` <br/>

1.  创建2D混合空间资产, 命名为BS_Locomotion_Walk <br/>
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/BlendSpace-2D.png" width="800" /> <br/> <br/>
2.  设置轴 <br/>
    
    -   横轴: 速度 <br/>
        
        | -    |            |
        |------|------------|
        | Name | Velocity   |
        | 范围 | [ 0, 600 ] |
    -   纵轴: ForwardVector 和 VelocityVector 的夹角 <br/>
        
        | -    |               |
        |------|---------------|
        | Name | Direction     |
        | 范围 | [ -180, 180 ] |
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/BS_Locomotion_Walk-Axis.png" width="400" /> <br/> <br/>
3.  设置动画 <br/>
    
    | ( `Velocity` , `Direction` ) | 动画资产 | 说明 |
    |------------------------------|------|----|
    | ( 0, 0 )                     | Idle    | 初始状态 |
    | ( 600, 0 )                   | Run_Fwd | 满速前进 |
    | ( 600, -180 ) 和 ( 600, 180 ) | Run_Bwd | 满速后退 |
    | ( 600, 90 )                  | Run_Rt  | 满速向右 |
    | ( 600, -90 )                 | Run_Lt  | 满速向左 |
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/BS_Locomotion_Walk.png" width="700" /> <br/> <br/>


### 将BS_Locomotion_Walk用作走路动画 {#将bs-locomotion-walk用作走路动画}

`ABP_BaseCharacter` <br/>

1.  将BS_Locomotion_Walk设置为Walk状态的输入 <br/>
2.  变量Velocity作为横轴Velocity的输入 <br/>
3.  添加变量 `Direction` <br/>
    
    | -   |       |
    |-----|-------|
    | 类型 | float |
    | 默认值 | 0     |
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/Direction.png" width="1200" /> <br/> <br/>
4.  变量Direction作为纵轴Direction的输入 <br/>
    
    <img src="/pic/角色和动画/添加转向动画/实现转向动画/ABP_BaseCharacter-AnimGraph-Locomotion-Walk.png" width="600" /> <br/> <br/>


## 在蓝图中计算夹角 {#在蓝图中计算夹角}

`虚幻编辑器` <br/>


### 在蓝图中计算夹角并设置变量 {#在蓝图中计算夹角并设置变量}

计算点乘时， `ForwardVector` 和 `VelocityVector` 都是单位向量 <br/>


#### 计算夹角 {#计算夹角}

当前并未在夹角为PI时做处理，后退动画偶有闪动但看似正常 <br/>

<img src="/pic/角色和动画/添加转向动画/实现转向动画/在蓝图中计算夹角.png" width="1200" /> <br/> <br/>


#### 接着设置IsRunning, 设置Direction {#接着设置isrunning-设置direction}

<img src="/pic/角色和动画/添加转向动画/实现转向动画/设置Direction.png" width="200" /> <br/> <br/>


#### 输出 {#输出}

1.  输出点乘的反余弦结果，静止时输出90 <br/>
2.  输出叉乘结果，静止、前进或后退时，坐标为 `0` 但是有正负 <br/>
3.  输出 `Sign` 结果，静止时为 `0` ，前进或后退时，其结果或为 `1` 或为 `-1` ，飘忽不定，但不为 `0` ，所以后退动画看似正常 <br/>
    可以做出合理推测：显示为 `0` 但不意味着为 `0` ，数值很小 <br/>
    叉乘时传入未单位化的 `Velocity` 无改善 <br/>
4.  同时按下后退和向左，或者后退和向右，正负 `3PI/4` 的动画较为刻意 <br/>
    ( PI/2, PI ) 和 ( -PI, -PI/2 ) 时可以只显示 `Run_Bwd` <br/>


### 绘制 ForwardVectr 和 VelocityVector 的叉乘结果 {#绘制-forwardvectr-和-velocityvector-的叉乘结果}

| -  |         |
|----|---------|
| 偏移 | 放大的叉乘结果 |

<img src="/pic/角色和动画/添加转向动画/实现转向动画/绘制叉乘结果.png" width="900" /> <br/> <br/>

运动时才有向量显示 <br/>

向前和向后运动时，偶有不明显的显示 <br/>


### 取消变量的设置 {#取消变量的设置}

接下来在代码计算夹角 <br/>


## 在代码中计算夹角 {#在代码中计算夹角}


### 添加接口, 返回Direction {#添加接口-返回direction}

`C++`       <br/>

1.  添加函数声明 <br/>
    `public` <br/>
    可在蓝图中调用，也可供其他类使用 <br/>
    `ShootThemUp: Player/STUBaseCharacter.h` <br/>
    ```cpp
    UFUNCTION(BlueprintCallable)
    float GetDirection() const;
    ```
2.  实现 <br/>
    
    -   速度为0时, 夹角为0 <br/>
    -   速度不为0, 叉乘结果为0时, 夹角为PI或-PI, 返回反余弦结果 <br/>
    
    `ShootThemUp: Player/STUBaseCharacter.cpp` <br/>
    ```cpp
    float ASTUBaseCharacter::GetDirection() const
    {
        if (GetVelocity().IsZero())
            return 0.0f;
    
        const FVector ForwardVector = GetActorForwardVector();
        const FVector VelocityNormalizedVector = GetVelocity().GetSafeNormal();
    
        const float DotProductResult = FVector::DotProduct(ForwardVector, VelocityNormalizedVector);
        const float Theta = FMath::RadiansToDegrees(FMath::Acos(DotProductResult));
    
        const FVector CrossProductResult = FVector::CrossProduct(ForwardVector, VelocityNormalizedVector);
    
        return (CrossProductResult.IsZero() ? Theta : FMath::Sign(CrossProductResult.Z) * Theta);
    }
    ```


### 代码优化: 前后左右移动的回调函数MoveForward和MoveRight {#代码优化-前后左右移动的回调函数moveforward和moveright}

`C++` <br/>
若 `Amount` 为0，直接返回 <br/>
`ShootThemUp: Player/STUBaseCharacter.cpp`       <br/>

```cpp
void ASTUBaseCharacter::MoveForward(float Amount)
{
    IsForward = Amount > 0.0f;
    if (Amount == 0.0f)
        return;
    AddMovementInput(GetActorForwardVector(), Amount);
}

void ASTUBaseCharacter::MoveRight(float Amount)
{
    if (Amount == 0.0f)
        return;
    AddMovementInput(GetActorRightVector(), Amount);
}
```


### 在蓝图中使用C++函数设置变量Direction {#在蓝图中使用c-plus-plus-函数设置变量direction}

`虚幻编辑器` <br/>
`ABP_BaseCharacter > EventGraph` <br/>

<img src="/pic/角色和动画/添加转向动画/在蓝图中使用C++函数计算夹角/在蓝图中使用C++函数计算夹角.png" width="700" /> <br/> <br/>


## 阻断动画蓝图无效状态 {#阻断动画蓝图无效状态}

当我们打开动画蓝图时，其以standalone方式运行。即使未在虚幻编辑器中运行游戏，在蓝图编辑器打开ABP_BaseCharacter，其处于运行状态。可以看到动画蓝图视口的 `Actor` 是有动画的。 <br/>


### 从EventBlueprintUpdateAnimation出发，TryGetPawnOwner得到空指针，停在CastToCharacter {#从eventblueprintupdateanimation出发-trygetpawnowner得到空指针-停在casttocharacter}

<img src="/pic/角色和动画/添加转向动画/在蓝图中使用C++函数计算夹角/ABP_BaseCharacter处于运行状态.png" width="1000" /> <br/> <br/>


### 添加打印名，验证动画蓝图运行 {#添加打印名-验证动画蓝图运行}

<img src="/pic/角色和动画/添加转向动画/在蓝图中使用C++函数计算夹角/添加打印名.png" width="800" /> <br/> <br/>

未在虚幻编辑器运行游戏，保持动画蓝图在前台，日志窗口一直有输出 <br/>

<img src="/pic/角色和动画/添加转向动画/在蓝图中使用C++函数计算夹角/添加打印名-日志.png" width="500" /> <br/> <br/>


### 未运行游戏时，阻断动画蓝图 {#未运行游戏时-阻断动画蓝图}

从 `EventBlueprintUpdateAnimation` 出发，添加 `IsValid` 宏，检查 `Pawn` 有效性 <br/>

<img src="/pic/角色和动画/添加转向动画/在蓝图中使用C++函数计算夹角/IsValid宏-Search.png" width="500" /> <br/> <br/>

<img src="/pic/角色和动画/添加转向动画/在蓝图中使用C++函数计算夹角/检查游戏是否运行.png" width="1000" /> <br/> <br/>

