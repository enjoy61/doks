---
title: "装备武器动画"
date: 2023-08-28T08:49:44
lastmod: 2023-10-05T22:42:26+08:00
draft: false
weight: 2017
---

## 说明 {#说明}

1.  装备武器时, 播放动画, 使用动画剪辑 `AnimMontage` 资产实现 <br/>
2.  播放装备武器动画时, 锁定其他操作, 使用动画提醒 `AnimNotify` 资产实现 <br/>


## 概览 {#概览}

-   [X] 使用动画剪辑播放装备武器动画 <br/>
-   [X] 创建动画剪辑资产 <br/>
-   [X] 在蓝图中实现Notify <br/>
-   [X] 创建UAnimNotify派生类 <br/>
-   [X] 在C++中实现Notify <br/>
-   [X] 在委托处理函数中判断骨骼网格体所属 <br/>


## 使用动画剪辑资产播放装备武器动画 {#使用动画剪辑资产播放装备武器动画}


### 添加数据成员, 指向装备武器动画剪辑 {#添加数据成员-指向装备武器动画剪辑}

`protected` <br/>
`ShootThemUp: Components/STUWeaponComponent.h` <br/>

```cpp
class UAnimMontage;

UPROPERTY(EditDefaultsOnly)
UAnimMontage *EquipAnimMontage;
```


### 添加函数, 播放动画剪辑 {#添加函数-播放动画剪辑}


#### 定义 {#定义}

-   `ShootThemUp: Components/STUWeaponComponent.h` <br/>
    `private` <br/>
    ```cpp
    void PlayAnimMontage(UAnimMontage *Animation);
    ```
-   `ShootThemUp: Components/STUWeaponComponent.cpp` <br/>
    ```cpp
    #include "Animation/AnimMontage.h"
    
    void USTUWeaponComponent::PlayAnimMontage(UAnimMontage *Animation)
    {
        ACharacter *Character = Cast<ACharacter>(GetOwner());
        if (!Character) return;
    
        Character->PlayAnimMontage(Animation);
    }
    ```


#### 调用 {#调用}

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
// EquipWeapon
PlayAnimMontage(EquipAnimMontage);
```


## 创建动画剪辑资产 {#创建动画剪辑资产}

`虚幻编辑器` <br/>

1.  选中Content/ExternalContent/Animation/Animations/TTP_Animations/Equip, 右键, 选择 `Create AnimMontage` <br/>
2.  命名为AM_Equip <br/>
3.  移动到Content/Player/Animations <br/>
4.  打开BP_STUBaseCharacter, 设置EquipAnimMontage为AM_Equip <br/>
    
    <img src="/pic/武器/装备武器动画/设置EquipAnimMontage.png" width="600" /> <br/> <br/>


### 当前问题 {#当前问题}

1.  频繁快速切换武器, 持续调用PlayAnimMontage, 表现为最后一次才完整播放装备武器动画 <br/>
2.  播放动画时, 可以射击 <br/>


### 引入动画提醒资产, 设想是, 在动画剪辑播放将近结束之前, 锁定其他操作 {#引入动画提醒资产-设想是-在动画剪辑播放将近结束之前-锁定其他操作}


## 提醒机制 {#提醒机制}

`Notify` <br/>
在动画剪辑资产的时间线上添加Notify事件; 动画提醒的实现基于把事件和特定帧绑定在一起 <br/>


### 蓝图 {#蓝图}

在动画蓝图 &gt; EventGraph中对事件进行处理 <br/>


### C++ {#c-plus-plus}

`Decorator` <br/>
覆写Notify函数, 添加处理 <br/>


## 查看动画资产 {#查看动画资产}

1.  双击打开AM_Equip, 点击暂停 <br/>
    
    <img src="/pic/武器/装备武器动画/点击暂停.png" width="600" /> <br/> <br/>
2.  移动滑杆, 可以查看时间线上对应的帧 <br/>
3.  时间线右侧有Notifies栏 <br/>


### Notifies栏 {#notifies栏}

有Track按钮, 可以添加其他轨道, 用于成组的事件 `Grouping Events` <br/>


## 在蓝图中测试提醒机制 {#在蓝图中测试提醒机制}


### 添加Notify事件 {#添加notify事件}

1.  双击打开AM_Equip <br/>
2.  将滑杆拖动到动画较后位置 <br/>
3.  在轨道1右键, 选择 `Add Notify > New Notify` <br/>
    
    <img src="/pic/武器/装备武器动画/新建Notify.png" width="400" /> <br/> <br/>
4.  命名为 `EquipFinished` <br/>
    
    <img src="/pic/武器/装备武器动画/EquipFinished.png" width="800" /> <br/> <br/>
5.  查看 <br/>
    
    <img src="/pic/武器/装备武器动画/查看EquipFinished.png" width="800" /> <br/> <br/>


### 在动画蓝图中处理事件 {#在动画蓝图中处理事件}

1.  打开ABP_BaseCharacter, 去到EventGraph <br/>
2.  在空白处右键, 选择 `Add Anim Notify Event > Event AnimNotify_EquipFinished` <br/>
    
    <img src="/pic/武器/装备武器动画/添加Notify事件.png" width="400" /> <br/> <br/>
3.  执行字符串打印 <br/>
    
    <img src="/pic/武器/装备武器动画/打印.png" width="600" /> <br/> <br/>
4.  切换武器时, 屏幕有输出 <br/>
    
    <img src="/pic/武器/装备武器动画/Equip.png" width="600" /> <br/> <br/>


## 在C++中实现Notify {#在c-plus-plus-中实现notify}

1.  创建AnimNotify的派生类, 作为委托服务的服务端 <br/>
2.  武器组件注册委托服务, 搭建好框架, 之后再实现播放装备武器动画的锁定和解锁逻辑 <br/>
3.  在装备武器动画剪辑中添加AnimNotify派生类事件 <br/>


### 新建AnimNotify的派生类 {#新建animnotify的派生类}

`虚幻编辑器` <br/>

| -     |                            |
|-------|----------------------------|
| 基类  | AnimNotify                 |
| 上级文件夹 | Animations                 |
| 访问属性 | Public                     |
| 名称  | STUEquipFinishedAnimNotify |

<img src="/pic/武器/装备武器动画/STUEquipFinishedAnimNotify.png" width="800" /> <br/> <br/>


### 添加头文件搜索路径 {#添加头文件搜索路径}

`ShootThemUp: ShootThemUp.Build.cs` <br/>

```csharp
PublicIncludePaths.AddRange(new string[]
{
    "ShootThemUp/Public/Player",
    "ShootThemUp/Public/Components",
    "ShootThemUp/Public/Dev",
    "ShootThemUp/Public/Weapon",
    "ShootThemUp/Public/UI",
    "ShootThemUp/Public/Animations"
});
```


### 查看UAnimNotify派生类 {#查看uanimnotify派生类}

`ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>

1.  事件发生时, 会调用UAnimNotify::Notify函数 <br/>
    `UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimNotifies/AnimNotify.h` <br/>
2.  定义委托类型, 使STUEquipFinishedAnimNotify作为服务端 <br/>
3.  覆写Notify函数, 通知客户端 <br/>


### 实现STUEquipFinishedAnimNotify {#实现stuequipfinishedanimnotify}


#### 定义委托类型, 并添加数据成员 {#定义委托类型-并添加数据成员}

`public`       <br/>
`ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>

```cpp
DECLARE_MULTICAST_DELEGATE(FOnNotifiedSignature);

FOnNotifiedSignature OnNotified;
```


#### 覆写Notify函数, 通知客户端 {#覆写notify函数-通知客户端}

-   `ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>
    `public` <br/>
    ```cpp
    virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference& EventReference) override;
    ```
-   `ShootThemUp: Animations/STUEquipFinishedAnimNotify.cpp` <br/>
    
    | -           |              |
    |-------------|--------------|
    | `Decorator` | 为已存在函数添加额外逻辑 |
    
    ```cpp
    void USTUEquipFinishedAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference& EventReference)
    {
        OnNotified.Broadcast();
        Super::Notify(MeshComp, Animation, EventReference);
    }
    ```


### 武器组件中, 对装备武器事件进行订阅 {#武器组件中-对装备武器事件进行订阅}


#### 实现处理函数, 事件发生时打印 {#实现处理函数-事件发生时打印}

1.  定义日志类型 <br/>
    `ShootThemUp: Components/STUWeaponComponent.cpp` <br/>
    ```cpp
    DEFINE_LOG_CATEGORY_STATIC(LogWeaponComponent, All, All);
    ```
2.  `ShootThemUp: Components/STUWeaponComponent.h` <br/>
    `private` <br/>
    ```cpp
    void OnEquipFinished();            
    ```
3.  `ShootThemUp: Components/STUWeaponComponent.cpp` <br/>
    ```cpp
    void USTUWeaponComponent::OnEquipFinished()
    {
        UE_LOG(LogWeaponComponent, Display, TEXT("Equip Finished!"));
    }
    ```


#### 订阅委托 {#订阅委托}

<!--list-separator-->

-  声明

    `private` <br/>
    `ShootThemUp: Components/STUWeaponComponent.h` <br/>
    
    ```cpp
    void InitAnimations();
    ```

<!--list-separator-->

-  获取AM_Equip中所有的提醒事件

    -   UAnimMontage派生自UAnimCompositeBase, UAnimCompositeBase派生自UAnimSequnceBase <br/>
    -   UAnimSequnceBase是动画基础类 `Base Animation Class` <br/>
    -   UAnimSequnceBase有数据成员Notifies数组, 存放FAnimNotifyEvent <br/>
        -   FAnimNotifyEvent存放Notify事件信息; 该结构体有一个指向UAnimNotify对象的指针 <br/>
    -   UAnimSequenceBase还有一个属性AnimNotifyTracks, 即在动画资产Notify一栏添加的Tracks, 只能在开发时访问 <br/>
    
    <!--listend-->
    
    ```cpp
    if (!EquipAnimMontage) return;
    
    const auto NotifyEvents = EquipAnimMontage->Notifies;
    ```

<!--list-separator-->

-  遍历所有事件, 注册STUEquipFinishedAnimNotify

    ```cpp
    #include "Animations/STUEquipFinishedAnimNotify.h"
    
    for (auto NotifyEvent : NotifyEvents)
    {
        auto EquipFinishedNotify = Cast<USTUEquipFinishedAnimNotify>(NotifyEvent.Notify);
        if (EquipFinishedNotify)
        {
            EquipFinishedNotify->OnNotified.AddUObject(this, &USTUWeaponComponent::OnEquipFinished);
            break;
        }
    }
    ```

<!--list-separator-->

-  完整实现

    `ShootThemUp: Components/STUWeaponComponent.cpp` <br/>
    
    ```cpp
    #include "Animations/STUEquipFinishedAnimNotify.h"
    
    void USTUWeaponComponent::InitAnimations()
    {
        if (!EquipAnimMontage) return;
    
        const auto NotifyEvents = EquipAnimMontage->Notifies;
        for (auto NotifyEvent : NotifyEvents)
        {
            auto EquipFinishedNotify = Cast<USTUEquipFinishedAnimNotify>(NotifyEvent.Notify);
            if (EquipFinishedNotify)
            {
                EquipFinishedNotify->OnNotified.AddUObject(this, &USTUWeaponComponent::OnEquipFinished);
                break;
            }
        }
    }
    ```

<!--list-separator-->

-  在BeginPlay中调用

    `ShootThemUp: Components/STUWeaponComponent.cpp` <br/>


## 在AM_Equip添加动画提醒事件 {#在am-equip添加动画提醒事件}

1.  打开AM_Equip <br/>
2.  在时间线最后添加Notify: STUEquipFinishedAnimNotify <br/>
    
    <img src="/pic/武器/装备武器动画/添加STUEquipFinishedAnimNotify.png" width="800" /> <br/> <br/>
3.  可在细节面板进行设置: 如修改Notify Color <br/>
    
    <img src="/pic/武器/装备武器动画/修改Notify颜色.png" width="1000" /> <br/> <br/>


## 查看 {#查看}

装备武器时, 日志成对打印: 所有的游戏角色均收到通知 <br/>

<img src="/pic/武器/装备武器动画/日志.png" width="600" /> <br/> <br/>


## 武器组件收到通知时, 判断装备武器的骨骼网格体所属 {#武器组件收到通知时-判断装备武器的骨骼网格体所属}


### 修改委托定义, 增加一个参数, 指向骨骼网格体 {#修改委托定义-增加一个参数-指向骨骼网格体}

`ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>

```cpp
// DECLARE_MULTICAST_DELEGATE(FOnNotifiedSignature);
DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*);
```


### 通知客户端时, 传参骨骼网格体 {#通知客户端时-传参骨骼网格体}

`ShootThemUp: Animations/STUEquipFinishedAnimNotify.cpp` <br/>

```cpp
// Notify
OnNotified.Broadcast(MeshComp);
```


### 修改客户端处理函数声明 {#修改客户端处理函数声明}

`ShootThemUp: Components/STUWeaponComponent.h` <br/>

```cpp
void OnEquipFinished(USkeletalMeshComponent *MeshComp);
```


### 修改客户端处理函数定义, 判断骨骼网格体所属 {#修改客户端处理函数定义-判断骨骼网格体所属}

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
void USTUWeaponComponent::OnEquipFinished(USkeletalMeshComponent *MeshComp)
{
    ACharacter *Character = Cast<ACharacter>(GetOwner());
    if (!Character || (Character->GetMesh() != MeshComp)) return;

    UE_LOG(LogWeaponComponent, Display, TEXT("Equip Finished!"));
}
```


## 查看 {#查看}

<img src="/pic/武器/装备武器动画/日志2.png" width="1000" /> <br/> <br/>

