---
title: "轨迹"
date: 2023-08-11T18:01:42
lastmod: 2023-08-12T22:49:23+08:00
draft: false
weight: 1006
---

## 概览 {#概览}

`Line Trace` <br/>

本节介绍如何使用武器进行射击 <br/>


### Socket {#socket}

1.  之前我们使用socket作为锚来附加武器 <br/>
2.  现在我们使用它来标记枪口 <br/>


## 添加Muzzle Socket {#添加muzzle-socket}

`虚幻编辑器` <br/>
之后会在代码中访问Socket, 以及从枪口发射子弹 <br/>

1.  双击打开 `Content > ExternalContent > Weapon > Weapons > Rifle` <br/>
2.  选中 `Skeleton Tree > RifleRoot` , 右键, 选择Add Socket, 命名为MuzzleSocket <br/>
3.  在细节面板设置Relative Location <br/>
    默认在武器坐标系的0坐标, 调整到枪口位置, 和各个轴对齐 <br/>
    
    <img src="/pic/武器/轨迹/添加MuzzleSocket.png" width="1200" /> <br/> <br/>
4.  可以更换观察视角, 调整枪口变换 <br/>
    
    <img src="/pic/武器/轨迹/设置Perspective.png" width="600" /> <br/> <br/>
    
    -   Top视角 <br/>
        
        <img src="/pic/武器/轨迹/Top.png" width="600" /> <br/> <br/>


## 沿着武器发射子弹的方向绘制线段 {#沿着武器发射子弹的方向绘制线段}

`C++` <br/>


### 添加MakeShot {#添加makeshot}

1.  包含发射子弹的所有逻辑 <br/>
2.  把Fire和Shot分开 <br/>
    -   如温切斯特连发步枪, 扣一下扳机, 连发数枚子弹 <br/>
    -   timer for shooting <br/>


#### 声明 {#声明}

`protected` <br/>
`ShootThemUp: Weapon/STUBaseWeapon.h`          <br/>


#### 空函数 {#空函数}

`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
void ASTUBaseWeapon::MakeShot() {}
```


#### 在Fire中调用 {#在fire中调用}


### 检查WeaponMeshComponent {#检查weaponmeshcomponent}

使用时不必检查 <br/>
`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// BeginPlay
check(WeaponMeshComponent);
```


### 实现MakeShot {#实现makeshot}


#### 获取MuzzleSocket变换 {#获取muzzlesocket变换}

<!--list-separator-->

-  添加Socket名

    `protected` <br/>
    `ShootThemUp: Weapon/STUBaseWeapon.h` <br/>
    
    ```cpp
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
    FName MuzzleSocketName = "MuzzleSocket";
    ```

<!--list-separator-->

-  获取Socket变换

    参数 <br/>
    
    1.  Socket名 <br/>
    2.  相对于指定座标系的Socket变换, 默认值是世界座标系 <br/>
    
    `ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>
    
    ```cpp
    // MakeShot
    const FTransform SocketTransform = WeaponMeshComponent->GetSocketTransform(MuzzleSocketName); // 默认世界坐标系
    ```


#### 绘制线段 {#绘制线段}

<!--list-separator-->

-  添加放大系数

    `ShootThemUp: Weapon/STUBaseWeapon.h` <br/>
    
    ```cpp
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
    float TraceMaxDistance = 1500.0f; // 1 unreal unit = 1cm > 15m
    ```

<!--list-separator-->

-  取出起点, 获取方向向量, 计算终点

    | -  |              |
    |----|--------------|
    | 起点 | Socket位置   |
    | 方向 | Socket旋转单位向量 |
    | 终点 | 起点 + 放大的方向向量 |
    
    `ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>
    
    ```cpp
    // MakeShot
    
    const FVector TraceStart = SocketTransform.GetLocation();
    
    const FVector ShootDirection = SocketTransform.GetRotation().GetForwardVector(); // 单位向量
    // GetRotation返回类型FQuat
    // 在此处FQuat比FRotator更方便, 因为GetForwardVector的存在, 可以获取X轴分量
    
    const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance;
    ```

<!--list-separator-->

-  获取World对象

    `ShootThemUp: Weapon/STUBaseWeapon.cpp`        <br/>
    
    ```cpp
    #include "Engine/World.h"         
    
    // MakeShot
    if(!GetWorld()) return;
    ```

<!--list-separator-->

-  绘制线段

    | 参数             |           |       |
    |----------------|-----------|-------|
    | bPersistentLines | 是否一直存在 | false |
    | LifeTime         | 持续时间, 单位s | 3     |
    | DepthPriority    | 绘制优先级 | 0     |
    
    `ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>
    
    ```cpp
    #include "DrawDebugHelpers.h"
    
    // MakeShot
    DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f);          
    ```


## 在虚幻编辑器中查看 {#在虚幻编辑器中查看}

1.  点击鼠标左键, 触发Fire <br/>
2.  轨迹与枪口垂直 <br/>
    
    <img src="/pic/武器/轨迹/轨迹与枪口垂直.png" width="800" /> <br/> <br/>
3.  修改 `Rifle` 变换 <br/>
    -   当前 <br/>
        
        <img src="/pic/武器/轨迹/Rifle-MuzzleSocket-Rotation.png" width="1000" /> <br/> <br/>
    -   前进方向对应X轴方向, 使X轴绕Y轴逆时针旋转90度 <br/>
        Relative Rotation &gt; Y=90 <br/>
        
        <img src="/pic/武器/轨迹/Rifle-MuzzleSocket-Rotation-Y90.png" width="1000" /> <br/> <br/>
    -   向上方向对应Z轴方向, 使其绕X轴顺时针旋转90度 <br/>
        Relative Rotation &gt; X=-90 <br/>
        
        <img src="/pic/武器/轨迹/Rifle-MuzzleSocket-Rotation-X-90.png" width="1000" /> <br/> <br/>
4.  效果图 <br/>
    
    <img src="/pic/武器/轨迹/射线效果图.png" width="800" /> <br/> <br/>


## 绘制相交点 {#绘制相交点}

`C++`      <br/>


### 获取与轨迹相交的物体信息 {#获取与轨迹相交的物体信息}

-   需要获得线段与场景中的物体的交点. Engine提供了很多支持该功能的函数, 我们使用UWorld对象的一个功能 <br/>
-   如果存在, LineTraceSingleByChannel通过函数参数返回与线段相交的第一个物体的信息 <br/>
-   LineTraceSingleByChannel返回true则有相交, false则无; 而HitResult中亦有bBlockingHit <br/>

| -                                 |                         |
|-----------------------------------|-------------------------|
| ECollisionChannel::ECC_Visibility | 阻挡了Visibility的物体才参与相交计算 |

`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// MakeShot
FHitResult HitResult;
GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);
```


### HitResult存放相交信息 {#hitresult存放相交信息}

-   需要交点 <br/>

| -            |              |
|--------------|--------------|
| 相交时间     |              |
| 交点         | ImpactPoint  |
| 法向量       |              |
| 指向相交Actor的指针 |              |
| 相交标志     | bBlockingHit |
| ...          |              |


### 绘制相交点 {#绘制相交点}

`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// MakeShot
if (HitResult.bBlockingHit)
{
    DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f);
}
```


## 查看相交点 {#查看相交点}

`虚幻编辑器` <br/>

1.  查看 `BP_STUBaseCharacter > CapsuleComponent > Collision` <br/>
    
    -   `Collision Presets, 为Custom` <br/>
    -   `Trace Responses > Visibility为Block` <br/>
        为Overlap或Ignore时, 不会参与相交计算 <br/>
    
    <img src="/pic/武器/轨迹/相交点-查看Character.png" width="1000" /> <br/> <br/>
2.  射中时, 绘制球 <br/>
    
    <img src="/pic/武器/轨迹/绘制交点.png" width="800" /> <br/> <br/>
    
    瞄准十字和射击点不在一处 <br/>


## 计算机游戏的射击机制 {#计算机游戏的射击机制}

`C++` <br/>

-   子弹从枪口射出, 是对真实世界中的射击进行模拟 <br/>
-   射击游戏中, 使子弹从Camera组件所在处设置, 该建模也适用于VR <br/>
    `Virtual Reality` <br/>
-   需要将玩家的CameraComponent作为计算起点 <br/>


### 在Weapon类访问CameraComponent {#在weapon类访问cameracomponent}

1.  创建武器时, 为其指定Owner <br/>
    -   我们在Actor中创建组件, 所以组件的Owner自动为Actor <br/>
    -   创建Actor时, 需要为其配置Owner <br/>
        SpawnActor时, 通过FActorSpawnParameters; 或者调用SetOwner, 武器的Owner和WeaponComponent的Owner相同 <br/>
        `ShootThemUp: Components/STUWeaponComponent.cpp` <br/>
        ```cpp
        // SpawnWeapon
        
        // CurrentWeapon->SetOwner(GetOwner());
        CurrentWeapon->SetOwner(Character);
        ```
2.  包含头文件 <br/>
    需要获取Character和Controller <br/>
    
    -   通过Character获取Controller <br/>
    -   通过Controller获取CameraComponent <br/>
    
    `ShootThemUp: Weapon/STUBaseWeapon.cpp`          <br/>
    ```cpp
    #include "GameFramework/Character.h"
    #include "GameFramework/PlayerController.h"
    ```
3.  获取Controller <br/>
    `ShootThemUp: Weapon/STUBaseWeapon.cpp`          <br/>
    ```cpp
    // MakeShot
    
    const auto Player = Cast<ACharacter>(GetOwner());
    if (!Player) return;
    
    const auto Controller = Player->GetController<APlayerController>();
    if (!Controller) return;
    ```
4.  获取CameraComponent的位置和朝向 <br/>
    
    -   PlayerCameraManager是全局类, 负责管理Camera, 可以直接获取Character的Camera组件 <br/>
    -   GetPlayerViewPoint访问PlayerCameraManager类 <br/>
    
    `ShootThemUp: Weapon/STUBaseWeapon.cpp`          <br/>
    ```cpp
    // MakeShot
    
    FVector ViewLocation;
    FRotator ViewRotation;
    Controller->GetPlayerViewPoint(ViewLocation, ViewRotation);
    ```


### 射击路线 {#射击路线}

| -  |               |
|----|---------------|
| 起点 | Camera位置    |
| 朝向 | Camera旋转的X轴分量 |

用以计算是否击中 <br/>
`ShootThemUp: Weapon/STUBaseWeapon.cpp`                <br/>

```cpp
const FVector TraceStart = ViewLocation;
const FVector ShootDirection = ViewRotation.Vector();
const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance;    

FHitResult HitResult;
GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);    
```


### 绘制 {#绘制}

起点是枪口, 若击中, 终点在击中物体上, 否则, 绘制射程的末尾 <br/>
`ShootThemUp: Weapon/STUBaseWeapon.cpp`       <br/>

```cpp
if (HitResult.bBlockingHit)
{
    DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f);
    DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f);
}
else
{
    DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f);
}
```


## 查看游戏射击机制绘图 {#查看游戏射击机制绘图}

1.  击中 <br/>
    
    <img src="/pic/武器/轨迹/击中.png" width="800" /> <br/> <br/>
2.  未击中 <br/>
    
    <img src="/pic/武器/轨迹/未击中.png" width="800" /> <br/> <br/>
    
    -   实际是CameraComponent作为起点 <br/>
    -   终点和瞄准十字近似重合; 射击时游戏角色身体没有旋转 <br/>


## 击中Mesh组件 {#击中mesh组件}

`虚幻编辑器` <br/>


### 验证: 我们射击游戏角色时, 打中的是CapsuleComponent {#验证-我们射击游戏角色时-打中的是capsulecomponent}

1.  打开BP_STUBaseCharacter, 选择CapsuleComponent, 去到Details &gt; Shape <br/>
    -   当前 <br/>
        
        <img src="/pic/武器/轨迹/CapsuleComponent-Shape-Current.png" width="400" /> <br/> <br/>
    -   设置 <br/>
        
        | -                   |    |
        |---------------------|----|
        | Capsule Half Height | 88 |
        | Capsule Radius      | 88 |
2.  在Console显示CapsuleComponent <br/>
    ```bash
    show collision           
    ```
3.  效果图 <br/>
    
    <img src="/pic/武器/轨迹/击中Capsule.png" width="800" /> <br/> <br/>


### 调整为击中骨骼网格体 {#调整为击中骨骼网格体}

1.  设置CapsuleComponent <br/>
    `BP_STUBaseCharacter > CapsuleComponent > Details > Collision > Collision Presets` <br/>
    -   当前 <br/>
        `TraceResponses > Visibility为Block, 参与交叉计算` <br/>
        
        <img src="/pic/武器/轨迹/Character-Capsule-CollisionPresets-Custom.png" width="400" /> <br/> <br/>
    -   恢复为默认 <br/>
        `TraceResponses > Visibility为Ignore, 不参与交叉计算` <br/>
        
        <img src="/pic/武器/轨迹/Character-Capsule-CollisionPresets-Pawn.png" width="400" /> <br/> <br/>
2.  设置MeshComponent <br/>
    `BP_STUBaseCharacter > CapsuleComponent > Details > Collision > Collision Presets`          <br/>
    -   默认为CharacterMesh <br/>
        `TraceResponses > Visibility为Ignore, 不参与交叉计算` <br/>
        
        <img src="/pic/武器/轨迹/Character-Mesh-CollisionPresets-CharacterMesh.png" width="1000" /> <br/> <br/>
    -   设置为Custom <br/>
        `将TraceResponses > Visibility设置为Block, 参与交叉计算` <br/>
        
        <img src="/pic/武器/轨迹/Character-Mesh-CollisionPresets-Custom.png" width="350" /> <br/> <br/>
3.  查看 <br/>
    -   击中Mesh <br/>
        
        <img src="/pic/武器/轨迹/击中Mesh.png" width="1000" /> <br/> <br/>
    -   可以击中两腿之间而不被CapsuleComponent阻挡 <br/>
        
        <img src="/pic/武器/轨迹/不被Capsule阻挡.png" width="1000" /> <br/> <br/>
4.  恢复CapsuleComponent的Shape <br/>


### 当前的问题: 射程的起点为Camera, 我们可以打到枪口无法打到的位置 {#当前的问题-射程的起点为camera-我们可以打到枪口无法打到的位置}

1.  从敌人的背后打到他 <br/>
    -   没调出来 <br/>
    -   解决思路: 限制轨迹和枪口方向的夹角为锐角 <br/>
2.  打到自己 <br/>
    -   没调出来 <br/>


#### 计算击中时忽略自己 {#计算击中时忽略自己}

1.  FCollisionQueryParams参数 <br/>
    将不参与相交计算的Actor添加到变量中 <br/>
    `ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>
    ```cpp
    FCollisionQueryParams CollisionParams;
    // CollisionParams.AddIgnoredActor(Player);
    CollisionParams.AddIgnoredActor(GetOwner());
    ```
2.  修改相交计算的参数 <br/>
    `ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>
    ```cpp
    // MakeShot
    GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams);
    ```


### 射中时, 输出骨骼信息 {#射中时-输出骨骼信息}

对不同部位造成伤害时, 减少的生命值不同, 如爆头直接死亡 <br/>


#### 实现 {#实现}

`C++` <br/>
`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// MakeShot         
UE_LOG(LogBaseWeapon, Display, TEXT("Bone: %s"), *HitResult.BoneName.ToString());
```


#### 查看日志 {#查看日志}

`虚幻编辑器` <br/>

<img src="/pic/武器/轨迹/骨骼信息.png" width="1000" /> <br/> <br/>

