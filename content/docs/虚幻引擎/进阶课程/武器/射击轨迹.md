---
title: "射击轨迹"
date: 2023-08-11T18:01:42
lastmod: 2023-08-18T19:59:24+08:00
draft: false
weight: 1006
---

## 概览 {#概览}

`Line Trace` <br/>

-   [X] 获取Socket变换信息 <br/>
-   [X] 获取游戏角色Camera组件的变换信息 <br/>
-   [X] 射击游戏对发射子弹的建模 <br/>
-   [X] 完成轨迹计算并获取碰撞信息 <br/>
-   [X] 绘制子弹轨迹和交点 <br/>
-   [X] 为轨迹计算添加屏蔽Actor <br/>


## Socket {#socket}

1.  之前我们使用Socket作为锚来附加武器 <br/>
2.  现在我们使用它来标记枪口, 获取变换信息 <br/>


## 为网格体Rifle添加Socket标记枪口, 获取变换信息 {#为网格体rifle添加socket标记枪口-获取变换信息}

`虚幻编辑器` <br/>

1.  双击打开 `Content > ExternalContent > Weapon > Weapons > Rifle` <br/>
2.  选中 `Skeleton Tree > RifleRoot` , 右键, 选择 `Add Socket` , 命名为MuzzleSocket <br/>
3.  在细节面板设置MuzzleSocket的位置 `Relative Location` <br/>
    默认在武器坐标系的0坐标, 调整到枪口位置 <br/>
    
    <img src="/pic/武器/轨迹/添加MuzzleSocket.png" width="1200" /> <br/> <br/>
4.  更换观察视角, 检查MuzzleSocket变换参数 <br/>
    
    <img src="/pic/武器/轨迹/设置Perspective.png" width="600" /> <br/> <br/>
    
    -   Top视角 <br/>
        
        <img src="/pic/武器/轨迹/Top.png" width="600" /> <br/> <br/>


## 模拟射击: 绘制子弹轨迹 {#模拟射击-绘制子弹轨迹}

`C++` <br/>
`STUBaseWeapon` <br/>

| -  |         |                                                |
|----|---------|------------------------------------------------|
| 起点 | 枪口    | MuzzleSocket的位置分量                         |
| 偏移 | 放大的武器朝向 | MuzzleSocket的前进方向: 通过MuzzleSocket的旋转分量, 获取前进向量 |
| 终点 | 起点 + 偏移 |                                                |


### 获取MuzzleSocket变换以得到线段所需信息 {#获取muzzlesocket变换以得到线段所需信息}

| Stub             |                                      |
|------------------|--------------------------------------|
| MuzzleSocketName | 保存Socket名称                       |
| TraceMaxDistance | 放大系数, 亦是子弹射击距离; 1 unreal unit = 1 cm |


#### 获取Socket变换 {#获取socket变换}

<!--list-separator-->

-  加载WeaponMeshComponent时检查其有效性

    在BeginPlay中调用; 使用时不必检查 <br/>
    
    ```cpp
    check(WeaponMeshComponent);
    ```

<!--list-separator-->

-  获取变换

    1.  参数: Socket名 <br/>
    2.  返回相对于指定座标系的Socket变换, 默认是世界座标系 <br/>
    
    <!--listend-->
    
    ```cpp
    const FTransform SocketTransform = WeaponMeshComponent->GetSocketTransform(MuzzleSocketName); // 默认世界坐标系
    ```


#### 获取起点 {#获取起点}

```cpp
const FVector TraceStart = SocketTransform.GetLocation();
```


#### 获取武器的朝向 {#获取武器的朝向}

```cpp
const FVector ShootDirection = SocketTransform.GetRotation().GetForwardVector(); // 单位向量
// GetRotation返回类型FQuat
// 在此处FQuat比FRotator更方便, 因为GetForwardVector的存在, 可以获取X轴分量
```


#### 计算终点 {#计算终点}

```cpp
const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance;         
```


### 绘制线段 {#绘制线段}


#### 获取World对象 {#获取world对象}

```cpp
#include "Engine/World.h"         

if(!GetWorld()) return;
```


#### 绘制线段 {#绘制线段}

| 参数             |           |       |
|----------------|-----------|-------|
| bPersistentLines | 是否一直存在 | false |
| LifeTime         | 持续时间, 单位s | 3     |
| DepthPriority    | 绘制优先级 | 0     |

```cpp
#include "DrawDebugHelpers.h"

DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f);          
```


### 完整代码 {#完整代码}


#### 添加数据成员 {#添加数据成员}

`ShootThemUp: Weapon/STUBaseWeapon.h` <br/>

```cpp
UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
FName MuzzleSocketName = "MuzzleSocket";

UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
float TraceMaxDistance = 1500.0f; // 1 unreal unit = 1cm > 15m
```


#### 检查WeaponMeshComponent {#检查weaponmeshcomponent}

`ShootThemUp: Weapon/STUBaseWeapon.cpp`        <br/>

```cpp
// BeginPlay
check(WeaponMeshComponent);
```


#### MakeShot {#makeshot}

包含发射子弹的所有逻辑; 如温切斯特连发步枪, 扣一下扳机, 连发数枚子弹, 所以和Fire分开 <br/>

1.  `ShootThemUp: Weapon/STUBaseWeapon.h` <br/>
    `protected` <br/>
    ```cpp
    void MakeShot();
    ```
2.  `ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>
    ```cpp
    #include "Engine/World.h"
    #include "DrawDebugHelpers.h"
    
    void ASTUBaseWeapon::MakeShot() {
        if(!GetWorld()) return;
    
        const FTransform SocketTransform = WeaponMeshComponent->GetSocketTransform(MuzzleSocketName);
        const FVector TraceStart = SocketTransform.GetLocation();
        const FVector ShootDirection = SocketTransform.GetRotation().GetForwardVector();
        const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance;
        DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f);
    }
    ```
3.  在Fire中调用 <br/>


## 在虚幻编辑器中查看 {#在虚幻编辑器中查看}

1.  点击鼠标左键, 触发Fire <br/>
2.  轨迹与枪口垂直: 未设置MuzzleSocket旋转信息, 需要与世界座标系对应轴方向一致 <br/>
    
    <img src="/pic/武器/轨迹/轨迹与枪口垂直.png" width="800" /> <br/> <br/>


## 配置MuzzleSocket旋转信息 {#配置muzzlesocket旋转信息}

`Rifle > Details` <br/>

1.  当前 <br/>
    
    <img src="/pic/武器/轨迹/Rifle-MuzzleSocket-Rotation.png" width="1000" /> <br/> <br/>
2.  前进方向对应X轴方向, 使X轴绕Y轴逆时针旋转90度 <br/>
    Relative Rotation &gt; Y=90 <br/>
    
    <img src="/pic/武器/轨迹/Rifle-MuzzleSocket-Rotation-Y90.png" width="1000" /> <br/> <br/>
3.  向上方向对应Z轴方向, 使其绕X轴顺时针旋转90度 <br/>
    Relative Rotation &gt; X=-90 <br/>
    
    <img src="/pic/武器/轨迹/Rifle-MuzzleSocket-Rotation-X-90.png" width="1000" /> <br/> <br/>
4.  效果图 <br/>
    
    <img src="/pic/武器/轨迹/射线效果图.png" width="800" /> <br/> <br/>


## 模拟射击: 绘制相交点 {#模拟射击-绘制相交点}

`C++` <br/>
给出子弹轨迹的起点和终点, 计算场景中与轨迹碰撞的物体, 保存到FHitResult对象中 <br/>


### HitResult存放碰撞结果 {#hitresult存放碰撞结果}

-   包含以下信息 <br/>
    
    | -            | 数据成员     |
    |--------------|----------|
    | 碰撞时间     |              |
    | 交点         | ImpactPoint  |
    | 法向量       |              |
    | 指向碰撞Actor的指针 |              |
    | 碰撞标志     | bBlockingHit |
    | ...          |              |
-   需要交点信息 <br/>


### 计算与轨迹发生碰撞的Actor {#计算与轨迹发生碰撞的actor}

-   Engine提供多个碰撞计算函数, 我们使用UWorld::LineTraceSingleByChannel <br/>
-   LineTraceSingleByChannel返回true则有碰撞, false则无; 而HitResult中亦有bBlockingHit <br/>
-   如果发生碰撞, LineTraceSingleByChannel通过函数参数返回与线段第一个发生碰撞的物体信息 <br/>

| -                                 |                         |
|-----------------------------------|-------------------------|
| ECollisionChannel::ECC_Visibility | 阻挡了Visibility的物体才参与轨迹计算 |

```cpp
FHitResult HitResult;
GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);
```


### 绘制相交点 {#绘制相交点}

```cpp
if (HitResult.bBlockingHit)
{
    DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f);
}
```


### 完整代码 {#完整代码}

`ShootThemUp: Weapon/STUBaseWeapon.cpp`       <br/>

```cpp
// MakeShot

FHitResult HitResult;
GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);
if (HitResult.bBlockingHit)
{
    DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f);
}
```


## 查看相交点 {#查看相交点}

`虚幻编辑器` <br/>


### 查看游戏角色Capsule组件的碰撞选项 {#查看游戏角色capsule组件的碰撞选项}

`BP_STUBaseCharacter > CapsuleComponent > Collision` <br/>

1.  `Collision Presets为Custom` <br/>
2.  `Trace Responses > Visibility为Block` <br/>
    为Overlap或Ignore时, 不会参与相交计算 <br/>

<img src="/pic/武器/轨迹/相交点-查看Character.png" width="1000" /> <br/> <br/>


### 射中时, 以交点为圆心绘制球 {#射中时-以交点为圆心绘制球}

<img src="/pic/武器/轨迹/绘制交点.png" width="800" /> <br/> <br/>


### 注意到, 瞄准十字与子弹轨迹不重合 {#注意到-瞄准十字与子弹轨迹不重合}


## 射击游戏中发射子弹建模 {#射击游戏中发射子弹建模}

`C++` <br/>

-   子弹从枪口射出, 是对真实世界中的射击进行模拟. 射击游戏中, 子弹从Camera组件位置射出. 该建模也适用于VR `Virtual Reality` <br/>
-   需要将子弹轨迹的起点改为Camera组件的位置 <br/>


### 在武器类获取游戏角色Camera组件的变换信息 {#在武器类获取游戏角色camera组件的变换信息}

1.  之前旋转游戏角色视角那里, 有提到是通过游戏角色控制器旋转Camera组件完成的; 获取游戏角色Camera组件的变换信息, 亦是通过游戏角色控制器得到 <br/>
2.  可以通过游戏角色获取其所属控制器 <br/>
3.  可以通过武器组件获取其所属游戏角色 <br/>
4.  武器组件生成武器时, 可以为武器设置所属, 即设置武器属于游戏角色 <br/>

<!--listend-->

```text
武器 > 游戏角色 > 游戏角色控制器 > 游戏角色Camera组件的变换信息
```


#### 武器类生成武器时, 设置其属于游戏角色 {#武器类生成武器时-设置其属于游戏角色}

`STUWeaponComponent` <br/>

-   SpawnActor时, 可以通过FActorSpawnParameters设置其所属; 或者调用SetOwner, 武器的Owner和WeaponComponent的Owner相同 <br/>
-   使用GetOwner函数和Character数据成员均可获取武器类所属游戏角色 <br/>

<!--listend-->

```cpp
// CurrentWeapon->SetOwner(GetOwner());
CurrentWeapon->SetOwner(Character);
```


#### 获取游戏角色控制器 {#获取游戏角色控制器}

`STUBaseWeapon` <br/>

```cpp
#include "GameFramework/Character.h"
#include "GameFramework/PlayerController.h"

const auto Player = Cast<ACharacter>(GetOwner());
if (!Player) return;

const auto Controller = Player->GetController<APlayerController>();
if (!Controller) return;
```


#### 通过游戏角色控制器获取Camera组件的变换信息: 位置和旋转 {#通过游戏角色控制器获取camera组件的变换信息-位置和旋转}

-   PlayerCameraManager是全局类, 负责管理Camera, 可以直接获取Character的Camera组件 <br/>
-   GetPlayerViewPoint访问PlayerCameraManager类 <br/>

<!--listend-->

```cpp
FVector ViewLocation;
FRotator ViewRotation;
Controller->GetPlayerViewPoint(ViewLocation, ViewRotation);
```


### 重新计算子弹轨迹和碰撞信息 {#重新计算子弹轨迹和碰撞信息}

| -  |            |
|----|------------|
| 起点 | Camera组件位置 |
| 偏移 | Camera组件旋转 |

```cpp
const FVector TraceStart = ViewLocation;
const FVector ShootDirection = ViewRotation.Vector();
const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance;    

FHitResult HitResult;
GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);    
```


### 绘制子弹轨迹和交点 {#绘制子弹轨迹和交点}

1.  子弹从Camera组件所在射出; 若击中, 到击中物体结束, 否则, 绘制射程 <br/>
2.  绘制子弹轨迹时, 起点仍是枪口, 终点为击中物体或射程终点 <br/>
3.  若击中物体, 绘制交点 <br/>

<!--listend-->

```cpp
if (HitResult.bBlockingHit)
{
    DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f);
    DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f);
}
else
{
    DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f);
}
```


### 完整代码 {#完整代码}

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
// SpawnWeapon
CurrentWeapon->SetOwner(Character);        
```

`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
#include "GameFramework/Character.h"
#include "GameFramework/PlayerController.h"

// MakeShot
void ASTUBaseWeapon::MakeShot()
{
    if(!GetWorld()) return;

    const auto Player = Cast<ACharacter>(GetOwner());
    if (!Player) return;

    const auto Controller = Player->GetController<APlayerController>();
    if (!Controller) return;

    FVector ViewLocation;
    FRotator ViewRotation;
    Controller->GetPlayerViewPoint(ViewLocation, ViewRotation);

    const FVector TraceStart = ViewLocation;
    const FVector ShootDirection = ViewRotation.Vector();
    const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance;    

    FHitResult HitResult;
    GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);    

    if (HitResult.bBlockingHit)
    {
        DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f);
        DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f);
    }
    else
    {
        DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f);
    }
}
```


## 查看 {#查看}

1.  击中 <br/>
    
    <img src="/pic/武器/轨迹/击中.png" width="800" /> <br/> <br/>
2.  未击中: 真实起点是Camera组件位置 <br/>
    
    <img src="/pic/武器/轨迹/未击中.png" width="800" /> <br/> <br/>
3.  终点和瞄准十字重合 <br/>


## 击中游戏角色时, 交点在骨骼网格体上 {#击中游戏角色时-交点在骨骼网格体上}

`虚幻编辑器` <br/>


### 当前击中游戏角色时, 交点在Capsule组件上 {#当前击中游戏角色时-交点在capsule组件上}


#### 放大Capsule组件显示 {#放大capsule组件显示}

打开BP_STUBaseCharacter, 选择CapsuleComponent, 去到Details &gt; Shape <br/>

-   当前 <br/>
    
    <img src="/pic/武器/轨迹/CapsuleComponent-Shape-Current.png" width="400" /> <br/> <br/>
-   设置 <br/>
    
    | -                   |    |
    |---------------------|----|
    | Capsule Half Height | 88 |
    | Capsule Radius      | 88 |


#### 显示Capsule组件 {#显示capsule组件}

1.  打开Console <br/>
2.  执行命令 <br/>
    ```bash
    show collision           
    ```


#### 效果图 {#效果图}

<img src="/pic/武器/轨迹/击中Capsule.png" width="800" /> <br/> <br/>


### 轨迹计算时, 忽略游戏角色Capsule组件, 将骨骼网格体考虑在内 {#轨迹计算时-忽略游戏角色capsule组件-将骨骼网格体考虑在内}


#### 设置Capsule组件的碰撞选项 {#设置capsule组件的碰撞选项}

`BP_STUBaseCharacter > CapsuleComponent > Details > Collision > Collision Presets` <br/>

-   当前 <br/>
    `TraceResponses > Visibility为Block, Capsule组件参与轨迹计算` <br/>
    
    <img src="/pic/武器/轨迹/Character-Capsule-CollisionPresets-Custom.png" width="400" /> <br/> <br/>
-   设置碰撞预设为Pawn <br/>
    `TraceResponses > Visibility为Ignore, Capsule组件不参与轨迹计算` <br/>
    
    <img src="/pic/武器/轨迹/Character-Capsule-CollisionPresets-Pawn.png" width="400" /> <br/> <br/>


#### 设置骨骼网格体的碰撞选项 {#设置骨骼网格体的碰撞选项}

`BP_STUBaseCharacter > Mesh > Details > Collision > Collision Presets` <br/>

-   碰撞预设默认为CharacterMesh, TraceResponses &gt; Visibility为Ignore, 骨骼网格体不参与轨迹计算 <br/>
    
    <img src="/pic/武器/轨迹/Character-Mesh-CollisionPresets-CharacterMesh.png" width="1000" /> <br/> <br/>
-   将碰撞预设设置为Custom, 将TraceResponses &gt; Visibility设置为Block, 使骨骼网格体参与轨迹计算 <br/>
    
    <img src="/pic/武器/轨迹/Character-Mesh-CollisionPresets-Custom.png" width="350" /> <br/> <br/>


### 查看 {#查看}

1.  可以击中骨骼网格体 <br/>
    
    <img src="/pic/武器/轨迹/击中Mesh.png" width="1000" /> <br/> <br/>
2.  子弹可以穿过游戏角色两腿之间而不被Capsule组件阻挡 <br/>
    
    <img src="/pic/武器/轨迹/不被Capsule阻挡.png" width="1000" /> <br/> <br/>


### 恢复CapsuleComponent的Shape {#恢复capsulecomponent的shape}


## 当前的问题: 射程的起点为Camera组件位置, 理论上, 我们可以打到枪口无法打到的位置 {#当前的问题-射程的起点为camera组件位置-理论上-我们可以打到枪口无法打到的位置}

1.  和敌人背对背时击中敌人 <br/>
    -   没调出来 <br/>
    -   解决思路: 要求武器朝向和子弹真实轨迹的夹角为锐角 <br/>
2.  打到自己 <br/>
    -   `BP_STUBaseCharacter > Camera组件 > Details > Transform > Location, 将XYZ置为0` <br/>
    -   解决思路: 轨迹计算时, 屏蔽游戏角色本身 <br/>


## 轨迹计算时屏蔽游戏角色本身 {#轨迹计算时屏蔽游戏角色本身}

`C++` <br/>


### 设置轨迹计算参数 FCollisionQueryParams {#设置轨迹计算参数-fcollisionqueryparams}

添加屏蔽Actor <br/>
`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// MakeShot

FCollisionQueryParams CollisionParams;
// CollisionParams.AddIgnoredActor(Player);
CollisionParams.AddIgnoredActor(GetOwner());
```


### 计算与轨迹发生碰撞的Actor: 修改参数 {#计算与轨迹发生碰撞的actor-修改参数}

`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// MakeShot
GetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams);
```


## 击中时, 输出骨骼信息 {#击中时-输出骨骼信息}

对不同部位造成伤害时, 游戏角色减少的生命值不同; 比如爆头可以导致游戏角色死亡 <br/>


### 存放在FHitResult中 {#存放在fhitresult中}

`C++` <br/>
`ShootThemUp: Weapon/STUBaseWeapon.cpp` <br/>

```cpp
// MakeShot         
UE_LOG(LogBaseWeapon, Display, TEXT("Bone: %s"), *HitResult.BoneName.ToString());
```


### 查看日志 {#查看日志}

`虚幻编辑器` <br/>

<img src="/pic/武器/轨迹/骨骼信息.png" width="1000" /> <br/> <br/>

