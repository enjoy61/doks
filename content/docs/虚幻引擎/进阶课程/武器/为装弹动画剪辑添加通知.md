---
title: "为装弹动画剪辑添加通知"
date: 2023-09-07T14:28:08
lastmod: 2023-09-07T16:48:17+08:00
draft: false
weight: 2022
---

## 说明 {#说明}

播放动画时, 不允许其他操作, 使用动画通知 `AnimNotify` 实现 <br/>


## 概览 {#概览}

-   [X] 为更换武器和装弹创建动画通知基类 <br/>
-   [X] 将动画通知逻辑移动到STUAnimNotify, 使STUEquipFinishedAnimNotify派生自STUAnimNotify <br/>
-   [X] 在装弹动画中添加结束事件, 注册处理函数 <br/>
-   [X] 手动装弹时检查, 完善开火和更换武器检查 <br/>


## 创建AnimNotify派生类 {#创建animnotify派生类}

<img src="/pic/武器/为装弹动画剪辑添加通知/Animations.png" width="500" /> <br/> <br/>


### 创建STUAnimNotify {#创建stuanimnotify}

| -  |            |
|----|------------|
| 基类 | AnimNotify |
| 路径 | Animations |
| 属性 | Public     |

<img src="/pic/武器/为装弹动画剪辑添加通知/STUAnimNotify.png" width="800" /> <br/> <br/>


### 创建STUReloadFinishedAnimNotify {#创建stureloadfinishedanimnotify}

| -  |               |
|----|---------------|
| 基类 | STUAnimNOtify |
| 路径 | Animations    |
| 属性 | Public        |

<img src="/pic/武器/为装弹动画剪辑添加通知/STUReloadFinishedAnimNotify.png" width="800" /> <br/> <br/>


## 把动画通知逻辑从STUEquipFinishedAnimNotify移动到STUAnimNOtify {#把动画通知逻辑从stuequipfinishedanimnotify移动到stuanimnotify}


### 实现STUAnimNotify {#实现stuanimnotify}

1.  定义委托类型 <br/>
    `ShootThemUp: Animations/STUAnimNotify.h`          <br/>
    ```cpp
    DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*);
    ```
2.  添加数据成员 <br/>
    `public` <br/>
    `ShootThemUp: Animations/STUAnimNotify.h`          <br/>
    ```cpp
    FOnNotifiedSignature OnNotified;           
    ```
3.  覆写虚函数 <br/>
    `public`          <br/>
    `ShootThemUp: Animations/STUAnimNotify.h` <br/>
    ```cpp
    virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference& EventReference) override;
    ```
    `ShootThemUp: Animations/STUAnimNotify.cpp` <br/>
    ```cpp
    void USTUAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference& EventReference)
    {
        OnNotified.Broadcast(MeshComp);
        Super::Notify(MeshComp, Animation, EventReference);
    }
    ```


### 修改STUEquipFinishedAnimNotify {#修改stuequipfinishedanimnotify}

1.  派生自STUAnimNotify, 修改头文件 <br/>
    `ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>
    ```cpp
    // #include "Animation/AnimNotifies/AnimNotify.h"
    #include "Animations/STUAnimNotify.h"
    
    class SHOOTTHEMUP_API USTUEquipFinishedAnimNotify : public STUAnimNotify
    ```
2.  屏蔽数据成员OnNotified <br/>
    `ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>
3.  屏蔽函数成员Notify <br/>
    `ShootThemUp: Animations/STUEquipFinishedAnimNotify.h` <br/>
    `ShootThemUp: Animations/STUEquipFinishedAnimNotify.cpp` <br/>


## 实现模板函数, 给定动画剪辑, 查找指定类型的通知事件 {#实现模板函数-给定动画剪辑-查找指定类型的通知事件}

`private`       <br/>
`ShootThemUp: Components/STUWeaponComponent.h` <br/>

```cpp
#include "Animation/AnimSequenceBase.h"

template<typename T>
T* FindNotifyByClass(UAnimSequenceBase *Animation)
{
    if (!Animation) return nullptr;

    const auto NotifyEvents = Animation->Notifies;
    for (auto NotifyEvent : NotifyEvents)
    {
        auto AnimNotify = Cast<T>(NotifyEvent.Notify);
        if (AnimNotify)
        {
            return AnimNotify;
        }
    }
    return nullptr;
}
```


### 修改InitAnimations中查找更换武器结束事件的方式 {#修改initanimations中查找更换武器结束事件的方式}

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
auto EquipFinishedNotify = FindNotifyByClass<USTUEquipFinishedAnimNotify>(EquipAnimMontage);
if (EquipFinishedNotify)
{
    EquipFinishedNotify->OnNotified.AddUObject(this, &USTUWeaponComponent::OnEquipFinished);
}
```


## 搭建装弹动画结束通知框架 {#搭建装弹动画结束通知框架}


### 在装弹动画剪辑中添加通知事件 {#在装弹动画剪辑中添加通知事件}

<img src="/pic/武器/为装弹动画剪辑添加通知/AM_Reload_Notify.png" width="800" /> <br/> <br/>

<img src="/pic/武器/为装弹动画剪辑添加通知/AM_Launcher_Reload_Notify.png" width="800" /> <br/> <br/>


### 定义空的回调函数 {#定义空的回调函数}

`private` <br/>
`ShootThemUp: Components/STUWeaponComponent.h`       <br/>

```cpp
void OnReloadFinished(USkeletalMeshComponent *MeshComp);
```

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
void USTUWeaponComponent::OnReloadFinished(USkeletalMeshComponent *MeshComp) { }
```


### 为装弹动画结束事件注册处理函数 {#为装弹动画结束事件注册处理函数}

`ShootThemUp: Components/STUWeaponComponent.cpp`       <br/>

```cpp
#include "Animations/STUReloadFinishedAnimNotify.h"

for (auto OneWeaponData : WeaponData)
{
    auto ReloadFinishedNotify = FindNotifyByClass<USTUReloadFinishedAnimNotify>(OneWeaponData.ReloadAnimMontage);
    if (ReloadFinishedNotify)
    {
        ReloadFinishedNotify->OnNotified.AddUObject(this, &USTUWeaponComponent::OnReloadFinished);
    }
}
```


## 手动装弹时进行检查 {#手动装弹时进行检查}


### 添加标志位 {#添加标志位}

`private` <br/>
`ShootThemUp: Components/STUWeaponComponent.h`       <br/>

```cpp
bool ReloadAnimInProgress = false;
```


### 实现检查接口 {#实现检查接口}

`private`       <br/>
`ShootThemUp: Components/STUWeaponComponent.h` <br/>

```cpp
bool CanReload() const;        
```

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
bool USTUWeaponComponent::CanReload() const
{
    return CurrentWeapon && !EquipAnimInProgress && !ReloadAnimInProgress;
}
```


### 播放装弹动画前进行检查, 设置标志位 {#播放装弹动画前进行检查-设置标志位}

`ShootThemUp: Components/STUWeaponComponent.cpp`       <br/>

```cpp
// Reload

if (!CanReload()) return;
ReloadAnimInProgress = true;
```


### 修改开火检查 {#修改开火检查}

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
// CanFire
return CurrentWeapon && !EquipAnimInProgress && !ReloadAnimInProgress;
```


### 修改更换武器检查 {#修改更换武器检查}

`ShootThemUp: Components/STUWeaponComponent.cpp` <br/>

```cpp
// CanEquip
return !EquipAnimInProgress && !ReloadAnimInProgress;
```


## 实现回调函数 {#实现回调函数}

`ShootThemUp: Components/STUWeaponComponent.cpp`      <br/>

```cpp
void USTUWeaponComponent::OnReloadFinished(USkeletalMeshComponent *MeshComp)
{
    ACharacter *Character = Cast<ACharacter>(GetOwner());
    if (!Character || (Character->GetMesh() != MeshComp)) return;

    ReloadAnimInProgress = false;    
}
```

