---
title: "自动治疗"
date: 2023-06-11T05:51:47
lastmod: 2023-08-07T15:35:20+08:00
draft: false
weight: 1007
---

## 说明 {#说明}

1.  `C++` <br/>
2.  治疗机制 <br/>
    -   受到伤害则延缓治疗；不再受到伤害才会自动治疗 <br/>
    -   使用定时器实现 <br/>
3.  获取定时器管理对象 <br/>
    -   `UActorComponent::GetOwner > AActor::GetWorldTimerManager` <br/>
    -   `UActorComponent::GetWorld > UWorld::GetTimerManager` <br/>


## 实现自动治疗 {#实现自动治疗}


### 添加治疗参数 {#添加治疗参数}

`protected` <br/>

| 参数     | 名称         |
|--------|------------|
| 使能自动治疗 | AutoHeal     |
| 首次治疗延后时长 | HealDelay    |
| 恢复生命值周期 | HealRate     |
| 单次恢复量 | HealModifier |

`ShootThemUp: Components/STUHealthComponent.h`         <br/>

```cpp
UPROPERTY(EditDefaultsOnly)
bool AutoHeal = true;

UPROPERTY(EditDefaultsOnly, meta = (EditCondition = "AutoHeal"))
float HealRate = 1.0f;

UPROPERTY(EditDefaultsOnly, meta = (EditCondition = "AutoHeal"))
float HealDelay = 3.0f;

UPROPERTY(EditDefaultsOnly, meta = (EditCondition = "AutoHeal"))
float HealModifier = 5.0f;
```


### 添加定时器 {#添加定时器}


#### 添加数据成员 {#添加数据成员}

`private` <br/>
`ShootThemUp: Components/STUHealthComponent.h` <br/>

```cpp
FTimerHandle HealTimer;
```


#### 搭建框架 {#搭建框架}

<!--list-separator-->

-  添加空的回调函数

    `ShootThemUp: Components/STUHealthComponent.cpp` <br/>
    
    ```cpp
    void USTUHealthComponent::OnHeal() {}
    ```

<!--list-separator-->

-  定时器接口

    `ShootThemUp: Components/STUHealthComponent.cpp` <br/>
    
    1.  头文件 <br/>
        ```cpp
        #include "Engine/World.h"
        #include "TimerManager.h"
        ```
    2.  开启定时器 <br/>
        ```cpp
        void USTUHealthComponent::StartHealTimer()
        {
            if (AutoHeal && GetWorld())
            {
                GetWorld()->GetTimerManager().SetTimer(HealTimer, 
                                                       this,
                                                       &USTUHealthComponent::OnHeal,
                                                       HealRate, 
                                                       true, 
                                                       HealDelay);
            }
        }
        ```
    3.  关闭定时器 <br/>
        ```cpp
        void USTUHealthComponent::StopHealTimer()
        {
            if (AutoHeal && GetWorld())
            {
                GetWorld()->GetTimerManager().ClearTimer(HealTimer);
            }
        }
        ```
    4.  接口声明 <br/>
        `private` <br/>
        `ShootThemUp: Components/STUHealthComponent.h` <br/>

<!--list-separator-->

-  回调函数声明

    `private` <br/>
    `ShootThemUp: Components/STUHealthComponent.h` <br/>


#### 回调函数实现 {#回调函数实现}

`ShootThemUp: Components/STUHealthComponent.cpp`         <br/>

```cpp
void USTUHealthComponent::OnHeal()
{
    SetHealth(Health + HealModifier);
    if (FMath::IsNearlyEqual(Health, MaxHealth))
    {
        StopHealTimer();
    }
}
```


### 游戏角色受到伤害延缓治疗 {#游戏角色受到伤害延缓治疗}

`ShootThemUp: Components/STUHealthComponent.cpp`               <br/>

```cpp
void USTUHealthComponent::OnTakeAnyDamage(AActor *DamagedActor, float Damage, const UDamageType *DamageType, AController *InstigatedBy,
                                          AActor *DamageCauser)
{
    if (Damage <= 0.0f || IsDead())
        return;

    if (!FMath::IsNearlyEqual(Health, MaxHealth))
        StopHealTimer();

    // Health -= Damage;
    SetHealth(Health - Damage);
    UE_LOG(LogHealthComponent, Display, TEXT("Damage: %.0f"), Damage);

    if (DamageType)
    {
        if (DamageType->IsA<USTUFireDamageType>())
        {
            UE_LOG(LogHealthComponent, Display, TEXT("So Hooooooot !!!"));
        }
        else if (DamageType->IsA<USTUIceDamageType>())
        {
            UE_LOG(LogHealthComponent, Display, TEXT("So Cooooooooold !!!"));
        }
    }

    if (IsDead())
    {
        OnDeath.Broadcast();
    }
    else
    {
        StartHealTimer();
    }
}
```


### 重写IsDead {#重写isdead}

`ShootThemUp: Components/STUHealthComponent.h` <br/>

```cpp
bool IsDead() const { return FMath::IsNearlyZero(Health); }
```

